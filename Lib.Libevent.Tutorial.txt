Konoha 言語 外部ライブラリ バインディング チュートリアル



ドリーさんへ、Markdown(http://daringfireball.net/projects/markdown/syntax)のつもりで書いていきます



# はじめに
  このチュートリアルでは、Konoha 言語から [libevent(http://libevent.org/)] を利用するために作成した src/package-devel/Lib.Libevent パッケージを例に、外部C/C++ライブラリを Konoha 言語にバインドする方法を例を示しながら説明していきます。

  また、Lib.Libevent パッケージの作成方針として、
* 移植性を保持するため、元の API に近いものとする
という方針で作成しています。
オブジェクト指向の形態には変更してはいますが、それ以外の引数は同じ形になるようにしています。

  チュートリアルに登場する例には行番号が振られていますが、github の konoha-project/konoha3 リポジトリ
>   [commit 66103b28762cede82a9844a7963c7d2727578b66](https://github.com/konoha-project/konoha3/tree/66103b28762cede82a9844a7963c7d2727578b66 "ベースソース")
  のソースを使用しています。実際のソースを眺めながら、このチュートリアルを読み進める際には、 commit ID に注意してください。



# 用語の説明
1. ライブラリ関数:	C/C++ ライブラリ
1. グルー関数:	Konoha 言語用グルー関数。Libevent_glue.c 内で定義されており、C の関数であるが、Konoha 言語からはメソッドとして呼ばれる。
1. Konoha メソッド:	Konoha 言語のメソッド
1. Konoha オブジェクト:	Konoha 言語のオブジェクト



# メソッドを定義する
## Konoha 言語の型, C言語 の型
C/C++ で Konoha 言語のメソッドを記述する場合、最も気を付けなければならない点は Konoha 言語と C 言語の間でデータ表現の違いです。

Konoha 言語ではプログラム記述には boolean 型、int 型, String 型, Array 型などが利用できます。
また、Type.Float パッケージを利用することで float 型の利用も可能となっています。
Konoha メソッドからグルー関数が呼ばれた際にメソッドの引数を取得しますが、この時に konoha.h で定義されている次の共用体を利用します。

    include/konoha3/konoha.h
    1017  #define K_FRAME_NCMEMBER \
    1018          uintptr_t   unboxValue;\
    1019          kbool_t     boolValue; \
    1020          kint_t      intValue; \
    1021          kfloat_t    floatValue; \
    1022          struct KonohaValueVar *previousStack;\
    1023          intptr_t    shift0;  \
    1024          struct KVirtualCode  *pc; \
    1025          kMethod     *calledMethod;\
    1026          kNameSpace  *calledNameSpace;\
    1027          uintptr_t    calledFileLine
    1028
    1029  #define K_FRAME_MEMBER \
    1030          kObject     *asObject;\
    1031          kObjectVar  *asObjectVar; \
    1032          const struct kNumberVar     *asNumber;\
    1033          kBoolean    *asBoolean;\
    1034          kInt        *asInt; \
    1035          kString     *asString;\
    1036          kArray      *asArray;\
    1037          kMethod     *asMethod;\
    1038          kFunc       *asFunc; \
    1039          kNameSpace  *asNameSpace;\
    1040          struct kSyntaxVar     *asSyntax;\
    1041          kToken      *asToken;\
    1042          kNode       *asNode;\
    1043          kException  *asException;\
    1044          const struct kFloatVar      *asFloat; \
    1045          struct kDateVar             *asDate;\
    1046          struct kRegExpVar           *asRegExp; \
    1047          const struct kBytesVar      *asBytes; \
    1048          struct kFileVar     *asFile;\
    1049          struct kIteratorVar *asIterator; \
    1050          struct kMap           *asMap;    \
    1051          struct kInputStream  *asInputStream; \
    1052          struct kOutputStream *asOutputStream;  \
    1053          struct kContext           *asContext;\
    1054          kint_t     dummy_intValue;\
    1055          kfloat_t   dummy_floatValue
    1056
    1057  struct KonohaValueVar {
    1058          union {
    1059                  K_FRAME_MEMBER;
    1060          };
    1061          union {
    1062                  K_FRAME_NCMEMBER;
    1063          };
    1064  };


## グルー関数の作成
実行中の Konoha はグルー関数を呼び出し、グルー関数からC/C++ライブラリ関数を呼び出すという流れになります。

グルー関数では、以下のことを行います。
1. Konoha スタックからの引数の取得
1. C/C++ 外部ライブラリ関数を呼び出し
1. 返り値を Konoha 言語のデータ型から C の型へ変換する。

それでは libevent ライブラリで定義されている event_add() 関数を cevent クラスの event_add() メソッドにバインドする例を示します。

この関数を呼び出すためのグルー関数は以下のようになります。

    src/package-devel/Lib.Libevent_glue.c
    177  static KMETHOD cevent_event_add(KonohaContext *kctx, KonohaStack* sfp)
    178  {
    179          kcevent *kcev = (kcevent *)sfp[0].asObject;
    180          kctimeval *tv = (kctimeval *)sfp[1].asObject;
    181          int ret = event_add(kcev->event, (tv->timeval.tv_sec == 0 && tv->timeval.tv_usec == 0) ? NULL : &tv->timeval);
    182          KReturnUnboxValue(ret);
    183  }

177 行から、cevent_event_add() 関数を開始します。
グルー関数はすべて同じインタフェース(引数にKonohaContext*型, KonohaStack*型、返り値がKMETHODの関数型)を持っています。

179, 180 行目では Konoha VM から受け取った引数(Konoha 言語の Object 型) を参照するため C の 構造体ポインタ型に変換して保持します。

グルー関数の第二引数である Konoha スタックは次の図のようになっています
*sfp[0]: this
*sfp[1]: 第一引数
*sfp[2]: 第二引数
*sfp[3]: 第三引数

TODO	中田さんの図に差し替え
![Alt test](http://konoha.sourceforge.jp/d/lib/exe/detail.php?id=guide%3Akpdg&media=guide:2-2.png "Konoha Stack image")

181行目では、そのローカル変数を引数として、event_add() 関数を呼び出します。返り値は、ローカル変数 ret に保存されます。

182 行目では、ローカル変数 ret をKonoha言語のint型に変換して、VMに返しています。
KReturn マクロは "include/konoha3/konoha.h" で定義されており、主に次を使用します。
* KReturn(o):	オブジェクト
* KReturnUnboxValue(d):	 基本型
* KReturnVoid():	void
* KReturnFloatValue(c):	float型(TODO check 受け取る側は Type.Float パッケージが必要？)


## グルー関数におけるメンバ変数へのアクセス
### Konoha クラス構造体の定義
C バインドにおける Konoha クラス構造の定義(以下の例は cevent クラスの構造)は次のように行ないます。

    src/package-devel/Lib.Libevent_glue.c
    45  typedef struct cevent {
    46          kObjectHeader h;
    47          struct event *event;
    48  } kcevent;

kObjectHeader を構造の先頭に配置し、以降に必要な変数を配置していきます。
cevent クラスのメンバ変数 event は Konoha 言語のオブジェクトから直接変更することはできないため、グルー関数を経由してのアクセスとなります。


### Konoha の名前空間への登録
C における定義を Konoha クラスとして動作させるために、Konoha の名前空間への登録を行ないます。

    src/package-devel/Lib.Libevent_glue.c
    517          // cevent
    518          KDEFINE_CLASS defcevent = {0};
    519          SETSTRUCTNAME(defcevent, cevent);
    520          defcevent.cflag     = KClassFlag_Final;
    521          defcevent.init      = cevent_Init;
    522  //      defcevent.reftrace  = cevent_Reftrace;
    523          defcevent.free      = cevent_Free;
    524          KClass *ceventClass = KLIB kNameSpace_DefineClass(kctx, ns, NULL, &defcevent, trace);

519 行の SETSTRUCTNAME マクロで cevent クラスへの cevent 構造体の関連付けを行ないます。

520 行で、このクラスの属性を指定します。
KClassFlag_* は konoha.h に定義されているので、そちらを参照してフラグを設定します。

TODO KClassFlag_* の一覧を記述する？

524 行の KLIB kNameSpace_DefineClass() で Konoha クラス名前空間への登録を行なっています。

#### クラス初期化関数
521 行は、cevent クラスの初期化関数 cevent_Init() を指定しています。

クラス初期化関数は、次の場合に呼び出されます。
*パッケージがロードされた際に各クラスの NULL オブジェクトを生成する
*オブジェクトが new される際、コンストラクタグルー関数を呼び出す前の初期化を行なう

    src/package-devel/Lib.Libevent_glue.c
    142  static void cevent_Init(KonohaContext *kctx, kObject *o, void *conf)
    143  {
    144          struct cevent *ev = (struct cevent *) o;
    145          ev->event = NULL;
    146  }

#### reftrace 関数
TODO 要確認
522 行は cevent クラスでは不要なためコメントアウトされていますが、GC による参照トレースに対する応答が必要なメンバを持つ場合は必要となります。

例えば、eventCBArg クラスでは次のように定義しています。

    src/package-devel/Lib.Libevent_glue.c
    363  static void eventCBArg_Reftrace(KonohaContext *kctx, kObject *o, KObjectVisitor *visitor)
    364  {
    365          struct eventCBArg *cba = (struct eventCBArg *) o;
    366          KRefTrace(cba->kcb);
    367          KRefTrace(cba->arg);
    368  }

KRefTrace マクロは NULL ポインタが許容されない場合に使用します。
NULL ポインタを許容する場合は、 KRefTraceNullable マクロを使用します。

#### free 関数
523 行は、cevent クラスのオブジェクトが解放される時に呼ばれる cevent_Free() 関数を指定しています。

cevent クラスでは libevent の event_free() を実施する必要があるので、153 行で呼び出しています。

    src/package-devel/Lib.Libevent_glue.c
    148  static void cevent_Free(KonohaContext *kctx, kObject *o)
    149  {
    150          struct cevent *ev = (struct cevent *) o;
    151
    152          if(ev->event != NULL) {
    153                  event_free(ev->event);
    154                  ev->event = NULL;
    155          }
    156  }


###メンバ変数へのアクセス
次の例は cevent クラスのコンストラクタの例ですが、メソッドでもアクセス方法は同じです。

    src/package-devel/Lib.Libevent_glue.c
    164  static KMETHOD cevent_new(KonohaContext *kctx, KonohaStack *sfp)
    165  {
    166          struct cevent *ev = (struct cevent *) sfp[0].asObject;
    167          struct cevent_base *cEvent_base = (struct cevent_base *)sfp[1].asObject;
    168          evutil_socket_t evd = (evutil_socket_t)sfp[2].intValue;
    169          short event = (short)(sfp[3].intValue & 0xffff);
    170          keventCBArg *cbArg = (keventCBArg *)sfp[4].asObject;    //deliver callback method
    171
    172          ev->event = event_new(cEvent_base->event_base, evd, event, cevent_callback_1st, cbArg);
    173          KReturn(ev);
    174  }

166 行目で this オブジェクトの参照をオブジェクト構造体ポインタ ev に取得しています。
このコンストラクタでは、event_new の結果を ev->event に保存することが目的ですが、それを 172 行目で行なっています。
そして、このオブジェクトを 173 行目で返してコンストラクタの終了となります。



## Konoha言語への登録
先ほど示したグルー関数は C の世界で定義された関数です。
Konoha 言語で利用できるようにするためには Konoha 側に、グルー関数で利用する引数、返り値の情報を設定しておく必要があります。
グルー関数の Konoha への登録は Libevent_PackupNameSpace() 関数にて行われます。
※Libevent_PackupNameSpace() の登録は後述する「Konoha スクリプトからパッケージをロードする際の内部動作」にて説明します

    src/package-devel/Lib.Libevent_glue.c
    505  static kbool_t Libevent_PackupNameSpace(KonohaContext *kctx, kNameSpace 
*ns, int option, KTraceInfo *trace)
    506  {
    
    (snip)
    
    570          int KType_cevent = ceventClass->typeId;
    
    (snip)
    
    591          KDEFINE_METHOD MethodData[] = {
    
    (snip)
    
    600                  _Public, _F(cevent_new), KType_cevent, KType_cevent, KMethodName_("new"), 4, KType_cevent_base, KFieldName_("cevent_base"), KType_Int, KFieldName_("evd"), KType_Int, KFieldName_("event"), KType_eventCBArg, KFieldName_("CBarg"),
    601                  _Public, _F(cevent_event_add), KType_Int, KType_cevent, KMethodName_("event_add"), 1, KType_ctimeval, KFieldName_("timeval"),
    
    (snip)
    
    626                  DEND, /* <= sentinel */
    627          };
    628          KLIB kNameSpace_LoadMethodData(kctx, ns, MethodData, trace);
    
    (snip)
    
    661
    662          return true;
    663  }


Konohaメソッドを登録するデータ構造MethodDataは以下のフォーマットとなっています。
* アノテーション , グルー関数のアドレス , 返り値の型 , Thisの型 , メソッド名 , 引数の数, 第1引数の型, 第1引数の型, 第2引数の型, 第2引数の型...

600 行で cevent コンストラクタを、601行で event_add() メソッドをそれぞれ次のように定義しています。
    @Public cevent cevent(cevent_base, int, int, eventCBArg);
    @Public cevent event_add(ctimeval);


最後にkNameSpace_LoadMethodData()によりメソッドの定義リストをNameSpaceに登録することでメソッドの呼び出しが可能となります。

_Public はメソッドに付与されたアノテーションを意味します。

メソッドには必ず0個以上のアノテーションを付与します。今回の場合、@Public @Immutableのアノテーションを付与しています。

メソッドに付与可能なアノテーションは以下のとおりです。
* _Public   ... @Public    ：クラス外部からのアクセスを許可する
* _Private  ... @Private   ：クラス外部からのアクセスを禁止する
* _Final    ... @Final     ：オーバーライド禁止
* _Const    ... @Const     ：引数が同じ場合，同じ物を返す
* _Static   ... @Static    ：インスタンス化せずにメソッドを呼び出すことを許可する
* _Im       ... @Immutable ：thisが変化しない
* _Coercion ... @Coercion  ：引数が自動的にキャストされる
* _Hidden   ... @Hidden
* _Virtual  ... @Virtual
* _Ignored  ... @IgnoredOverride


## C によるグルークラスの制約
### C で定義するグルークラスは Final なクラスとして定義しなければない

C で定義されたクラスをスクリプト側で継承したい場合には Libevent_kick.k における定義のようにラップするオブジェクトを作成することで回避する方法をとります。

    src/package-devel/Lib.Libevent_kick.k
    32  class event_base {
    33          cevent_base cevbase;
    34          @Private Map/*TODO Map[event]*/ evMap;
    35
    36          event_base() {
    37                  cevbase = new cevent_base();
    38                  evMap = new Map();
    39          }
    40  
    41          @Public int event_dispatch() {
    42                  return cevbase.event_dispatch();
    43          }
    
    (snip)
    
    52  }

### 構造体はオブジェクトとしてラップする必要がある。



# Generics
libevent ではイベントによりコールバック関数の引数が異なっています。

グルー関数の C から Konoha のコールバックメソッドを呼び出すためには、コールバックメソッドの定義に Func 型を使用し、その引数の型を Generics で定義する必要があります。


    src/package-devel/Lib.Libevent_glue.c
    578          //eventCB_p
    579          kparamtype_t eventCB_p[] = {{KType_Int, 0}, {KType_Int, 0}, {KType_Object, 0}};
    580          KClass *ceventCBfunc = KLIB KClass_Generics(kctx, KClass_Func, KType_void, 3, eventCB_p);
    581          int KType_ceventCBfunc = ceventCBfunc->typeId;
    
    (snip)
    
    591          KDEFINE_METHOD MethodData[] = {
    
    (snip)
    

    614                  // eventCBArg
    615                  _Public, _F(eventCBArg_new), KType_eventCBArg, KType_eventCBArg, KMethodName_("new"), 2, KType_ceventCBfunc, KFieldName_("konoha_CB"), KType_Object, KFieldName_("CBarg"),

    
    (snip)
    
    627          };
    628          KLIB kNameSpace_LoadMethodData(kctx, ns, MethodData, trace);

579 - 581 が コールバック用 Func 型の定義になります。
1. 579 行で Func の引数を定義しています。この場合は Func[int, int, Object] に相当します。
1. 580 行で KLIB KClass_Generics() を呼ぶことにより、Func の Generics 型を Konoha のクラスとして登録しています。 KLIB KClass_Generics() の引数は
* コンテキスト, クラス, 返り値の型, 引数の数, 引数の定義テーブル
となります。
1. 581 行では、[Konoha言語への登録] で説明した MethodData[] へ登録するための型情報を取得し、615 行でそれを使用しています。

この例では eventCBArg クラスのコンストラクタを定義していますが、これを呼ぶのは

    src/package-devel/Lib.Libevent_kick.k
    60          event(event_base evbase, int evd, int evCat, Func[void, int, int, Object] cb, Object cbArg) {
    61                  cev = new cevent(evbase.cevbase, evd, evCat, new eventCBArg(cb, cbArg));
    62                  this.evBase = evbase;
    63          }

の 61 行のようになります。



# libevent コールバックから Konoha コールバックメソッドの呼び出し
libevent コールバックは C の関数しかサポートしていないため、libevent コールバックとして Konoha メソッドを直接設定できません。
そのため、
1. libevent から C のコールバック関数を呼び出される
1. C コールバック関数から Konoha メソッドを呼び出す
という二段階の手続きが必要となります。


## Konoha コールバックメソッドの引数の保持













# Konoha スクリプトからパッケージをロードする際の内部動作
## パッケージの場所を特定する
  現在のKonohaではパッケージのインストール場所として以下の3つのディレクトリを順に探索し、最初にLib.Libeventディレクトリがあった場所からライブラリをロードします。
>   $INSTALL_PREFIX/konoha/$VERSION/package/
>   $HOME/.konoha/konoha/$VERSION/package/
>   $KONOHA_HOME/package/

   (なお、$INSTALL_PREFIXはデフォルトでは/usr/local, $VERSIONは2013年3月現在0.3が入ります。また、$KONOHA_HOMEは環境変数としてKONOHA_HOMEを指定した場合、探索の対象となります。)

## 拡張ライブラリを読み込む
  パッケージの場所が特定できたらKonohaは拡張ライブラリの探索を行います。
  ライブラリは"パッケージ名_glue.so"(今回の例ではLibevent_glue.so)という名前を想定しています。(なお、MacOSXの場合拡張子はdylibとなります)
  拡張ライブラリのロードには以下の手順を踏みます。
  まず、ライブラリを初期化するため"パッケージ名"_Init関数(今回の例ではLibevent_Init)を呼び出します。

  Konohaでは各パッケージはそれぞれ別々の名前空間で区切られており、パッケージ間で定義をimport, exportするための機構が用意されています。
パッケージに新たに定数などを定義する際にはTutorial1_PackupNameSpace関数を利用します。多くのパッケージではメソッド定義や文法定義などを行います。
他のパッケージにシンボルを公開する場合にはTutorial1_ExportNameSpace関数を利用します。定数定義などでこの関数を利用しています。

    src/package-devel/Lib.Libevent_glue.c
    670  KDEFINE_PACKAGE *Libevent_Init(void)
    671  {
    672      static KDEFINE_PACKAGE d = {0};
    673      KSetPackageName(d, "libevent2", "0.1");
    674      d.PackupNameSpace       = Libevent_PackupNameSpace;
    675      d.ExportNameSpace       = Libevent_ExportNameSpace;
    676      return &d;
    677  }

## パッケージスクリプトを読み込む
パッケージの読み込みの最終ステップはパッケージ側で定義されているスクリプトをロードすることです。
"パッケージ名"_kick.kのスクリプトがロードされます。(今回の例ではLibevent_kick.k)
拡張ライブラリ内でCで記述されたメソッドのラッパーメソッドなどはここに記述されます。

